package main

import "fmt"

// https://leetcode.com/problems/find-a-value-of-a-mysterious-function-closest-to-target/

// Winston was given the above mysterious function func. He has an integer array arr and an integer target
// and he wants to find the values l and r that make the value |func(arr, l, r)-target| minimum possible.
//  func(arr, l ,r) {
//  	if r<l {
//  		return -100000000
//  	}
//  	ans = arr[l]
//  	for i=l+1; i<=r; i++ {
//  		ans = ans & arr[i]
//  	}
//  	return ans
//  }
// Return the minimum possible value of |func(arr, l, r) - target|.
// Notice that func should be called with the values l and r where 0 <= l, r < arr.length.
// Example 1:
//   Input: arr = [9,12,3,7,15], target = 5
//   Output: 2
//   Explanation: Calling func with all the pairs of [l,r] = [[0,0],[1,1],[2,2],[3,3],[4,4],
//     [0,1],[1,2],[2,3],[3,4],[0,2],[1,3],[2,4],[0,3],[1,4],[0,4]], 
//     Winston got the following results [9,12,3,7,15,8,0,3,7,0,0,3,0,0,0]. 
//     The value closest to 5 is 7 and 3, thus the minimum difference is 2.
// Example 2:
//   Input: arr = [1000000,1000000,1000000], target = 1
//   Output: 999999
//   Explanation: Winston called the func with all possible values of [l,r] and he always got 1000000, 
//     thus the min difference is 999999.
// Example 3:
//   Input: arr = [1,2,4,8,16], target = 0
//   Output: 0
// Constraints:
//   1 <= arr.length <= 10^5
//   1 <= arr[i] <= 10^6
//   0 <= target <= 10^7

// let set[i] be the set of unique values of {AND(arr[0...i], AND(arr[1...i], ..., AND(arr[i...i])))
// then the size of set[i] won't exceed log(arr[i]). and for set[i+1], it's generated by
// {arr[i+1] & x | x ∈ set[i]} ∪ {arr[i+1]}.
// so the complexity is O(nlog(max(arr)))
func closestToTarget(arr []int, target int) int {
	set := make(map[int]struct{})
	min := 100000000
	set[arr[0]] = struct{}{}
	for i:=1; i<len(arr); i++ {
		newset := make(map[int]struct{})
		for k := range set {
			if abs(k-target) < min {
				min = abs(k-target)
			}
			newset[k&arr[i]] = struct{}{}
		}
		newset[arr[i]] = struct{}{}
		set = newset
	}

	// we haven't check minimal for last set
	for k := range set {
		if abs(k-target) < min {
			min = abs(k-target)
		}
	}
	return min
}

func abs(a int) int {
	if a<0 {
		return -a
	}
	return a
}

func main() {
	closestToTarget([]int{9,12,3,7,11,14,9,13}, 0)
	for _, v := range []struct{arr []int; target int; ans int} {
		{[]int{9,12,3,7,15}, 5, 2},
		{[]int{1000000,1000000,1000000}, 1, 999999},
		{[]int{1,2,4,8,16}, 0, 0},
	} {
		fmt.Println(closestToTarget(v.arr, v.target), v.ans)
	}
}
